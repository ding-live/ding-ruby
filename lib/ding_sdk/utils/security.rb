# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'cgi'
require 'date'
require 'sorbet-runtime'
require 'base64'

module DingSDK
  module Utils
    extend T::Sig

    sig { params(req: Faraday::Request, security: Object).void }
    def self.configure_request_security(req, security)
      return if security.nil?
      sec_fields = security.fields
      sec_fields.each do |sec_field|
        value = security.send(sec_field.name)
        next if value.nil?

        metadata = sec_field.metadata[:security]
        next if metadata.nil?

        _parse_security_option(req, value) if metadata[:option]

        if metadata[:scheme]
          # Special case for basic auth which could be a flattened struct
          if metadata[:sub_type] == 'basic' && !value.respond_to?(:fields)
            _parse_security_scheme(req, metadata, security)
          else
            _parse_security_scheme(req, metadata, value)
          end
        end
      end
    end

    sig { params(req: Faraday::Request, option: Object).void }
    def self._parse_security_option(req, option)
      opt_fields = option.fields
      opt_fields.each do |opt_field|
        metadata = opt_field.metadata[:security]
        next if metadata.nil? || !metadata.include?(:scheme)

        _parse_security_scheme(req, metadata, option.send(opt_field.name))
      end
    end

    sig { params(req: Faraday::Request, scheme_metadata: T::Hash[Symbol, String], scheme: Object).void }
    def self._parse_security_scheme(req, scheme_metadata, scheme)
      scheme_type = scheme_metadata[:type]
      sub_type = scheme_metadata[:sub_type]

      if scheme.respond_to? :fields
        if scheme_type == 'http' && sub_type == 'basic'
          _parse_basic_auth_scheme(req, scheme)
          return
        end

        scheme_fields = scheme.fields
        scheme_fields.each do |field|
          metadata = field.metadata[:security]
          next if metadata.nil? || metadata[:field_name].nil?

          value = scheme.send(field.name)
          _parse_security_scheme_value(req, scheme_metadata, metadata, value)
        end
      else
        _parse_security_scheme_value(req, scheme_metadata, scheme_metadata, scheme)
      end
    end

    sig do
      params(req: Faraday::Request, scheme_metadata: T::Hash[Symbol, String],
             security_metadata: T::Hash[Symbol, String], value: Object).void
    end
    def self._parse_security_scheme_value(req, scheme_metadata, security_metadata, value)
      scheme_type = scheme_metadata[:type]
      sub_type = scheme_metadata[:sub_type]

      header_name = security_metadata[:field_name]

      case scheme_type
      when 'apiKey'
        case sub_type
        when 'header'
          req.headers[header_name] = value
        when 'query'
          req.params[header_name] = value
        when 'cookie'
          req.cookies[header_name] = value
        else
          raise StandardError, 'not supported'
        end
      when 'openIdConnect'
        req.headers[header_name] = value.downcase.start_with?('bearer ') ? value : "Bearer #{value}"
      when 'oauth2'
        req.headers[header_name] = value.downcase.start_with?('bearer ') ? value : "Bearer #{value}"
      when 'http'
        if sub_type == 'bearer'
          req.headers[header_name] = value.downcase.start_with?('bearer ') ? value : "Bearer #{value}"
        elsif sub_type != 'custom'
          raise StandardError, 'not supported'
        end
      else
        raise StandardError, 'not supported'
      end
    end

    sig { params(req: Faraday::Request, scheme: Object).void }
    def self._parse_basic_auth_scheme(req, scheme)
      username, password = ''

      scheme_fields = scheme.fields
      scheme_fields.each do |scheme_field|
        metadata = scheme_field.metadata[:security]
        next if metadata.nil? || !metadata.include?(:field_name)

        field_name = metadata[:field_name]
        value = scheme.send(scheme_field.name)

        username = value if field_name == 'username'
        password = value if field_name == 'password'
      end

      data = "#{username}:#{password}".encode
      # Use strict_encode, because encode adds newlines after 60 chars
      # https://docs.ruby-lang.org/en/3.0/Base64.html#method-i-encode64
      req.headers['Authorization'] = "Basic #{Base64.strict_encode64(data)}"
    end
  end
end
